// class Solution {
// public:
//     int minMutation(string start, string end, vector<string>& bank) {
//       int ans=0;
//         int res=0;
//         for(int i=start.length()-1;i>=0;i--)
//         {
//             if(start[i]!=end[i])
//             {
//                 res++;
//                 start[i]=end[i];
//                 // cout<<start<<" ";
//                 if(find(bank.begin(),bank.end(),start)!=bank.end())
//                 {
//                   ans++;
//                 }
                
//             }
//         }
//         if(ans!=res)
//         {
//             return -1;
//         }
//         return ans;
//         }
// };

class Solution {
public:
    int minMutation(string start, string end, vector<string>& bank) {
    unordered_set<string>st{bank.begin(),bank.end()};
    if(!st.count(end))
    {
        return -1;
    }
    queue<string>q;
    q.push(start);
    int n,step=0;
    string cur,t;
        while(!q.empty())
        {
           n=q.size();
            while(n--)
            {
                cur=q.front();
                q.pop();
                if(cur==end)
                {
                    return step;
                }
                st.erase(cur);   // to avoid redundancy
                for(int i=0;i<8;i++)
                {
                t=cur;
                t[i]='A';
				if(st.count(t)) q.push(t);
				t[i]='C';
				if(st.count(t)) q.push(t);
				t[i]='G';
				if(st.count(t)) q.push(t);
				t[i]='T';
				if(st.count(t)) q.push(t);
                }
            }
            step++;
        }
    return -1;
    }
};

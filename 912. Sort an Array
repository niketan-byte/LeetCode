class Solution {
public:
void merge(vector<int>& arr,int st,int end)
{
    int mid = st+(end-st)/2;
    int len1 = mid-st+1;
    int len2 = end-mid;
    vector<int>f(len1);
    vector<int>s(len2);

    int mn = st;

    // copy 
    for(int i=0;i<len1;i++)
    {
        f[i] = arr[mn++];
    }
    mn = mid+1;
    for(int i=0;i<len2;i++)
    {
        s[i] = arr[mn++];
    }

    // merge
int idx1=0;
int idx2=0;

mn = st;
while(idx1<len1 && idx2<len2)
{
    if(f[idx1]<s[idx2])
    {
        arr[mn++] = f[idx1++]; 
    }
    else{
        arr[mn++] = s[idx2++];
    }
}

while(idx1<len1)
{
    arr[mn++] = f[idx1++]; 
}
while(idx2<len2)
{
    arr[mn++] = s[idx2++]; 
}

}


void solve(vector<int>& arr,int st, int end)
{
    if(st>=end)
    {
        return;
    }
    int mid = st+(end-st)/2;

    solve(arr,st,mid);
    solve(arr,mid+1,end);

    merge(arr,st,end);
}

    vector<int> sortArray(vector<int>& nums) {
    //    priority_queue<int,vector<int>,greater<int>>pq;
    //    for(auto i:nums)
    //    {
    //        pq.push(i);
    //    }
    //    for(int i=0;i<nums.size();i++)
    //    {
    //        nums[i] = pq.top();
    //        pq.pop();
    //    }
    //    return nums;


//     int mn = *min_element(nums.begin(),nums.end());
//     int mx = *max_element(nums.begin(),nums.end());
//     map<int,int>mp;
//     for(int i=0;i<nums.size();i++)
//     {
//        mp[nums[i]]++;
//     }
//    int i=0;
//    int k=mn;
//     while(mx>=k)
//     {
//         int t = mp[k];
//         while(t--)
//         {
//             nums[i] = k;
//             i++;
//         }
//         k++;
//     }
//     return nums;
solve(nums,0,nums.size()-1);
return nums;
    }
};

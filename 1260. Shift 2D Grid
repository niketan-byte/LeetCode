// class Solution {
// public:
//     vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {
//         vector<int>ans;
//         int m = grid.size();
// int n = grid[0].size();
//         for(int i=0;i<m;i++)
//         {
//             for(int j=0;j<n;j++)
//             {
//                 ans.push_back(grid[i][j]);
//             }
//         }
//          int N = ans.size();
//        //    for(int i=0;i<N;i++)
//        //  {
//        //      cout<<ans[i]<<" ";
//        //  }
//        // cout<<endl;
       
//  while(k--){
//       int last = ans[N-1];
//     for(int i=N-1;i>0;i--)
//             {
//                 ans[i]=ans[i-1];
                
//             }
//     ans[0]=last;
// }
//         // for(int i=0;i<N;i++)
//         // {
//         //     cout<<ans[i]<<" ";
//         // }
//         int index=0;
//          for(int i=0;i<m;i++)
//         {
//             for(int j=0;j<n;j++)
//             {
//                 grid[i][j] = ans[index];
//                 index++;
//             }
//         }
//         return grid;
//     }
// };


// class Solution {
// public:
//     vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {
//     int m = grid.size();
//     int n = grid[0].size();
//         vector<vector<int>>ans(m,vector<int>(n,0));
//         for(int i=0;i<m*n;i++)
//         {
//             // x is col and y is col
//             int ori_x = i%n;
//             int ori_y = i/n;
//             int new_x = (ori_x+k)%n;
//             int new_y = (ori_y + (ori_x+k)/n)%m;
//             ans[new_y][new_x]=grid[ori_y][ori_x];
//         }
//         return ans;
//     }
// };


// vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {
//         int m = grid.size();
//         int n = grid[0].size();
//         vector<vector<int>> res (m, vector<int> (n, 0));
//         for (int i=0;i<m;i++){
//             for (int j=0;j<n;j++){
//                 int newCol = (j+k)%n;
//                 int countWrapArounds = (j+k)/n;
//                 int newRow = (i+countWrapArounds)%m;
//                 res[newRow][newCol] = grid[i][j];
//             }
//         }
//         return res;
//     }
